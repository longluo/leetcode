//ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head å’Œä¸€ä¸ªæ•´æ•° val ï¼Œè¯·ä½ åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰æ»¡è¶³ Node.val == val çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å› æ–°çš„å¤´èŠ‚ç‚¹ ã€‚
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šhead = [1,2,6,3,4,5,6], val = 6
//è¾“å‡ºï¼š[1,2,3,4,5]
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šhead = [], val = 1
//è¾“å‡ºï¼š[]
// 
//
// ç¤ºä¾‹ 3ï¼š 
//
// 
//è¾“å…¥ï¼šhead = [7,7,7,7], val = 7
//è¾“å‡ºï¼š[]
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [0, 10â´] å†… 
// 1 <= Node.val <= 50 
// 0 <= val <= 50 
// 
// Related Topics é€’å½’ é“¾è¡¨ ğŸ‘ 862 ğŸ‘ 0


// 2022-04-11 21:56:58
// By Long Luo

#include<bits/stdc++.h>
#include <ListNode.h>

using namespace std;

//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // Recursion time: O(n) space: O(1)
    ListNode *removeElements(ListNode *head, int val) {
        if (head == NULL) {
            return head;
        }

        head->next = removeElements(head->next, val);
        if (head->val == val) {
            return head->next;
        } else {
            return head;
        }
    }
};
//leetcode submit region end(Prohibit modification and deletion)

int main() {
    Solution s;

}